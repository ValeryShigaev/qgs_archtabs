# -*- coding: utf-8 -*-
"""
/***************************************************************************
 ArchTabs
                                 A QGIS plugin
 This plugin allows you to get border description tables.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2022-07-12
        git sha              : $Format:%H$
        copyright            : (C) 2022 by Valery
        email                : shigaevaler@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QFileDialog, QTableWidgetItem
from qgis.core import QgsProject, QgsMapLayer
# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .ArchTabs_dialog import ArchTabsDialog
from .utils.xl_loader import XlHandler
from .utils.logger import log
from .utils.data_handler import DataHandler
import os.path
from typing import Dict, List


class ArchTabs:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """

        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'ArchTabs_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&ArchTabs')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None
        self.output_file = None
        self.dlg = None
        self.layers = QgsProject.instance().layerTreeRoot().children()
        self.turning_p_box = None
        self.landmarks_box = None
        self.bench_box = None
        self.turn_order = None
        self.land_names = None
        self.crs_box = None
        self.proj_check = None
        self.mult_check = None
        self.start_spin = None
        self.end_spin = None
        self.add = None
        self.multi_warn = None
        self.parts_table = None
        self.rem_button = None
        self.surf_check = None
        self.surf_label = None
        self.surf_box = None
        self.de_button = None
        self.en_button = None
        self.ru_button = None
        self.run_button = None
        self.landmarks_err = None
        self.benchmark_err = None
        self.t_points_err = None
        self.file_err = None
        self.success = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('ArchTabs', message)

    def add_action(
            self,
            icon_path,
            text,
            callback,
            enabled_flag=True,
            add_to_menu=True,
            add_to_toolbar=True,
            status_tip=None,
            whats_this=None,
            parent=None):

        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToVectorMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/ArchTabs/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'ArchTabs'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginVectorMenu(
                self.tr(u'&ArchTabs'),
                action)
            self.iface.removeToolBarIcon(action)

    def select_output_file(self) -> None:
        filename, _filter = QFileDialog.getSaveFileName(
            self.dlg, "Select output file", "", '*.xls')
        self.output_file = f"{filename}.xls"
        self.dlg.FileLine.setText(self.output_file)

    def fill_boxes(self) -> None:
        try:
            boxes = [self.turning_p_box, self.landmarks_box, self.bench_box,
                     self.surf_box]
            for box in boxes:
                box.addItems([layer.name() for layer in self.layers if
                              layer.layer().type() == QgsMapLayer.VectorLayer])
        except Exception as e:
            self.layers = QgsProject.instance().layerTreeRoot().children()
            log.error(f"projects layers was changed {e}")

    def show_fields_on_load(self) -> None:
        try:
            self.turn_order.addItems([field.name()
                                      for field in self.layers
                                      [self.turning_p_box.currentIndex()].
                                     layer().fields()])
            self.land_names.addItems([field.name()
                                      for field in self.layers
                                      [self.landmarks_box.currentIndex()].
                                     layer().fields()])
        except Exception as e:
            self.layers = QgsProject.instance().layerTreeRoot().children()
            log.error(f"projects layers was changed {e}")

    def show_fields(self, key: str) -> None:
        if key is "points":
            self.turn_order.clear()
            self.turn_order.addItems([field.name()
                                      for field in self.layers
                                      [self.turning_p_box.currentIndex()].
                                     layer().fields()])
        elif key is "names":
            self.land_names.clear()
            self.land_names.addItems([field.name()
                                      for field in self.layers
                                      [self.landmarks_box.currentIndex()].
                                     layer().fields()])

    def clear_boxes(self) -> None:
        self.turning_p_box.clear()
        self.landmarks_box.clear()
        self.bench_box.clear()
        self.turn_order.clear()
        self.land_names.clear()
        self.surf_box.clear()

    def proj_checkbox(self):
        if self.proj_check.isChecked():
            self.crs_box.setEnabled(False)
        else:
            self.crs_box.setEnabled(True)

    def mult_checkbox(self):
        if self.mult_check.isChecked():
            self.start_spin.setEnabled(True)
            self.end_spin.setEnabled(True)
            self.add.setEnabled(True)
            self.parts_table.setEnabled(True)
            self.rem_button.setEnabled(True)
        else:
            self.start_spin.setEnabled(False)
            self.end_spin.setEnabled(False)
            self.add.setEnabled(False)
            self.parts_table.setEnabled(False)
            self.rem_button.setEnabled(False)

    def check_table_ranges(self, start: int, end: int) -> bool:
        table = self.parts_table
        row_count = table.rowCount()
        table_range = list()
        if row_count:
            for row in range(row_count):
                for num in range(int(table.item(row, 0).text()),
                                 int(table.item(row, 1).text()) + 1):
                    if num not in table_range:
                        table_range.append(num)
        for num in range(start, end + 1):
            if num in table_range:
                return False
        return True

    def clear_table(self):
        table = self.parts_table
        row_count = table.rowCount()
        if row_count:
            print(f'{row_count} - count')
            for row in range(row_count):
                print(f'{row} - row')
                table.removeRow(0)

    def insert_into_table(self):

        self.multi_warn.hide()
        start, end = self.start_spin.value(), self.end_spin.value()
        if (start is 0) or (end is 0) or (start is end):
            self.multi_warn.show()
        else:
            table = self.parts_table
            if start > end:
                start, end = end, start
            if self.check_table_ranges(start, end):
                row_position = table.rowCount()
                table.insertRow(row_position)
                table.setItem(row_position, 0, QTableWidgetItem(str(start)))
                table.setItem(row_position, 1, QTableWidgetItem(str(end)))
            else:
                self.multi_warn.show()

    def surface_checkbox(self):
        if self.surf_check.isChecked():
            self.surf_label.setEnabled(True)
            self.surf_box.setEnabled(True)
        else:
            self.surf_label.setEnabled(False)
            self.surf_box.setEnabled(False)

    def get_lang(self) -> str:
        if self.de_button.isChecked():
            return "Deutsch"
        elif self.en_button.isChecked():
            return "English"
        return "Russian"

    def get_basic_values(self) -> Dict[str, any]:
        values = dict()
        if self.proj_check.isChecked():
            values["crs"] = QgsProject.instance().crs()
        else:
            values["crs"] = self.crs_box.crs()
        t_points = self.layers[self.turning_p_box.currentIndex()].layer()
        values["t_points"] = t_points
        points_order = t_points.fields()[self.turn_order.currentIndex()]
        idx = t_points.fields().indexFromName(points_order.name())
        points_list = [feature.attributes()[idx] for feature in
                       t_points.getFeatures()]
        values["order"] = points_list
        values["order_name"] = \
        self.layers[self.turning_p_box.currentIndex()].layer().fields()[
            self.turn_order.currentIndex()].name()
        landmarks = self.layers[self.landmarks_box.currentIndex()].layer()
        values["landmarks"] = landmarks
        land_names = landmarks.fields()[self.land_names.currentIndex()]
        idx = landmarks.fields().indexFromName(land_names.name())
        names_list = [feature.attributes()[idx] for feature in
                      landmarks.getFeatures()]
        values["names"] = names_list

        benchmark = self.layers[self.bench_box.currentIndex()].layer()
        values["benchmark"] = benchmark
        values["lang"] = self.get_lang()
        values = self.get_advanced_values(values)
        print(values)
        return values

    def get_advanced_values(self, values: Dict[str, any]):
        data = list()
        table = self.parts_table
        print(table)
        print(table.rowCount())
        print(table.columnCount())
        if self.mult_check.isChecked():
            print("checked")
            for row in range(self.parts_table.rowCount()):
                data.append(list())
                for column in range(self.parts_table.columnCount()):
                    idx = int(self.parts_table.item(row, column).text())
                    data[row].append(idx)
        values["parts"] = data
        if self.surf_check.isChecked():
            s_layers = self.surf_box.checkedItems()
            layers = [QgsProject.instance().mapLayersByName(item) for item
                      in s_layers]
            values["surface"] = layers
        return values

    def handle(self) -> None:
        dh = DataHandler()
        xl = XlHandler()
        self.success.hide()
        self.hide_errs()
        errors = list()
        user_data = self.get_basic_values()
        if dh.landmarks_handler(user_data):
            if xl.write_data(dh.landmarks_data, "landmarks"):
                log.error("success landmarks info")
            else:
                log.error("bad landmarks info")
            log.error("success landmarks data")
        else:
            log.error("bad landmarks data")
            errors.append("landmarks")
        if dh.coord_handler(user_data):
            if xl.write_data(dh.coord_data, "coordinates"):
                log.error("success coord info")
            else:
                log.error("bad coord info")
            log.error("success coord data")
        else:
            errors.append("coords")
            log.error("bad coord data")

        if dh.borders_handler(user_data):
            if xl.write_data(dh.bound_data, "description"):
                log.error("success borders info")
            else:
                log.error("bad borders info")
        else:
            errors.append("borders")
            log.error("bad borders data")

        if xl.save(self.output_file):
            log.error("success file")
        else:
            errors.append("file")
            log.error("bad file")

        self.show_errs(errors) if len(errors) else self.success.show()
        dh.clear_data()

    def show_errs(self, errors: List[str]) -> None:
        if "landmarks" in errors:
            self.landmarks_err.show()
            self.benchmark_err.show()
        if "coords" in errors:
            self.t_points_err.show()
        if "borders" in errors:
            self.t_points_err.show()
        if "file" in errors:
            self.file_err.show()

    def hide_errs(self):
        self.multi_warn.hide()
        self.landmarks_err.hide()
        self.benchmark_err.hide()
        self.t_points_err.hide()
        self.file_err.hide()

    def set_labels(self) -> None:
        self.multi_warn.setText("<font color='red'>check your data</font>")
        self.run_button.setStyleSheet("background-color: #31AB17")
        self.landmarks_err.setText("<font color='red'>check this data</font>")
        self.benchmark_err.setText("<font color='red'>check this data</font>")
        self.t_points_err.setText("<font color='red'>check this data</font>")
        self.file_err.setText("<font color='red'>check output file</font>")
        self.success.setText("<font color='#31AB17'>Completed!</font>")

    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep
        # reference
        # Only create GUI ONCE in callback, so that it will only load when
        # the plugin is started

        if self.first_start:
            self.first_start = False
            self.dlg = ArchTabsDialog()
            self.turning_p_box = self.dlg.TurningPointsBox
            self.landmarks_box = self.dlg.LandmarksBox
            self.bench_box = self.dlg.BenchmarkBox
            self.turn_order = self.dlg.TurningOrder
            self.land_names = self.dlg.LandmarksName
            self.crs_box = self.dlg.CrsBox
            self.proj_check = self.dlg.ProjectionCheck
            self.mult_check = self.dlg.MultCheckBox
            self.start_spin = self.dlg.StartSpinBox
            self.end_spin = self.dlg.EndSpinBox
            self.add = self.dlg.AddButton
            self.parts_table = self.dlg.PartsTable
            self.multi_warn = self.dlg.MultiWarn
            self.rem_button = self.dlg.RemoveButton
            self.surf_check = self.dlg.SurfaceCheckBox
            self.surf_label = self.dlg.SurfaceLabel
            self.surf_box = self.dlg.SurfaceComboBox
            self.de_button = self.dlg.Deutch
            self.en_button = self.dlg.English
            self.ru_button = self.dlg.Russian
            self.run_button = self.dlg.runButton
            self.landmarks_err = self.dlg.landmarksLabel
            self.benchmark_err = self.dlg.benchmarkLabel
            self.t_points_err = self.dlg.turningpointsLabel
            self.file_err = self.dlg.fileLabel
            self.success = self.dlg.successLabel
            self.add.clicked.connect(self.insert_into_table)
            self.dlg.FileButton.clicked.connect(self.select_output_file)

        self.success.hide()
        self.hide_errs()
        self.clear_boxes()
        self.fill_boxes()
        self.show_fields_on_load()
        self.turning_p_box.activated.connect(lambda:
                                             self.show_fields("points"))
        self.landmarks_box.activated.connect(lambda:
                                             self.show_fields("names"))
        self.proj_check.clicked.connect(lambda: self.proj_checkbox())
        self.mult_check.clicked.connect(lambda: self.mult_checkbox())
        self.rem_button.clicked.connect(lambda: self.clear_table())
        self.surf_check.clicked.connect(lambda: self.surface_checkbox())
        self.set_labels()
        self.run_button.clicked.connect(self.handle)
        self.crs_box.setCrs(QgsProject.instance().crs())

        # show the dialog
        self.dlg.show()

        # Run the dialog event loop
        result = self.dlg.exec_()

        # See if Cancel was pressed
        if result:
            pass
